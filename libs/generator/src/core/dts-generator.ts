import { type WriteStream, createWriteStream } from "node:fs";
import { dirname, join, relative, resolve } from "node:path";

import { Savable } from "@velnora/devkit";
import type { DtsGeneratorApi, Logger, Package } from "@velnora/types";

import { debug } from "../utils/debug";
import type { TypeGenerator } from "./type-generator";

export class DtsGenerator extends Savable<DtsGenerator> implements DtsGeneratorApi {
  private readonly appPath: string;
  private readonly indexDtsFile: string;

  private readonly files = new Set<string>();
  private readonly indexFileStream: WriteStream;

  constructor(
    pkg: Package,
    private readonly typeGenerator: TypeGenerator,
    private readonly logger: Logger
  ) {
    const appPath = pkg.root.replace(process.cwd(), "").slice(1);
    super(join(appPath, "patch.json"), debug.extend("types"));
    this.appPath = appPath;
    this.indexDtsFile = join(this.appPath, "types/index.d.ts");
    this.indexFileStream = createWriteStream(this.fs.resolve(this.indexDtsFile));

    this.init();
  }

  generateDts(path: string, content: string) {
    console.log(path);
    this.patchIndexFile(path);
  }

  private init() {
    const velnoraRootedApp = resolve(this.typeGenerator.velnoraRoot, "packages", this.appPath);
    const generatedFileUnderVelnora = `${velnoraRootedApp}.d.ts`;

    const relativePath = relative(dirname(generatedFileUnderVelnora), this.indexDtsFile);

    void Promise.allSettled([
      this.fs.writeAsync(`/// <reference path="${relativePath}" />`, generatedFileUnderVelnora),
      this.fs.writeAsync(`// This file is auto-generated by Velnora. Do not edit manually.\n`, this.indexDtsFile),
      this.loadAsync()
    ]).then(result => {
      const rejectedResults = result.filter(r => r.status === "rejected");
      if (rejectedResults.length > 0) {
        this.logger.error(new AggregateError(rejectedResults.map(r => r.reason as Error)));
      }
    });
  }

  private patchIndexFile(path: string) {
    return this.withPersistence(() => {
      if (this.files.has(path)) return;
      this.files.add(path);
      this.indexFileStream.write(`/// <reference path="${path}" />\n`);
    });
  }

  protected fromJSON(json: ReturnType<DtsGenerator["toJSON"]>) {
    if (!json) return;
    if (this.fs.stats(this.indexDtsFile).mtimeMs !== json.lastUpdatedMs) return;
    json.patchedFiles.forEach(file => this.files.add(file));
  }

  toJSON() {
    return { patchedFiles: Array.from(this.files), lastUpdatedMs: this.fs.stats(this.indexDtsFile).mtimeMs };
  }
}
