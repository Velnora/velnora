import { type WriteStream, createWriteStream } from "node:fs";
import { dirname, join, relative, resolve } from "node:path";

import { Savable } from "@velnora/devkit";
import type { DtsGeneratorApi, Logger, Package } from "@velnora/types";

import { debug } from "../utils/debug";
import type { TypeGenerator } from "./type-generator";

export class DtsGenerator extends Savable<DtsGenerator> implements DtsGeneratorApi {
  private readonly appPath: string;
  private readonly indexDtsFile: string;

  private readonly files = new Set<string>();
  private indexFileStream: WriteStream | null = null;

  private isInitialized = false;

  constructor(
    pkg: Package,
    private readonly typeGenerator: TypeGenerator,
    private readonly logger: Logger
  ) {
    const appPath = pkg.root.replace(process.cwd(), "").slice(1);
    super(join(appPath, "patch.json"), debug.extend("types"));
    this.appPath = appPath;
    this.indexDtsFile = join(this.appPath, "types/index.d.ts");
  }

  generateDts(path: string, content: string) {
    console.log(path);
    this.patchIndexFile(path);
  }

  toJSON() {
    return { patchedFiles: Array.from(this.files), lastUpdatedMs: this.fs.stats(this.indexDtsFile).mtimeMs };
  }

  protected fromJSON(json: ReturnType<DtsGenerator["toJSON"]>) {
    if (!json) return;
    if (this.fs.stats(this.indexDtsFile).mtimeMs !== json.lastUpdatedMs) return;
    json.patchedFiles.forEach(file => this.files.add(file));
  }

  private getOrCreateIndexStream() {
    if (!this.isInitialized) this.init();

    const indexFile = this.fs.resolve(this.indexDtsFile);
    if (!this.fs.exists(indexFile)) this.fs.write("", indexFile, { force: true });
    this.indexFileStream = createWriteStream(indexFile);
    return this.indexFileStream;
  }

  private init() {
    if (this.isInitialized) return;
    this.isInitialized = true;
    const velnoraRootedApp = resolve(this.typeGenerator.velnoraRoot, "packages", this.appPath);
    const generatedFileUnderVelnora = `${velnoraRootedApp}.d.ts`;

    const relativePath = relative(dirname(generatedFileUnderVelnora), this.indexDtsFile);

    void Promise.allSettled([
      this.fs.writeAsync(`/// <reference path="${relativePath}" />`, generatedFileUnderVelnora, { force: true }),
      this.fs.writeAsync(`// This file is auto-generated by Velnora. Do not edit manually.\n`, this.indexDtsFile, {
        force: true
      }),
      this.loadAsync()
    ]).then(result => {
      const rejectedResults = result.filter(r => r.status === "rejected");
      if (rejectedResults.length > 0) {
        this.logger.error(new AggregateError(rejectedResults.map(r => r.reason as Error)));
      }
    });
  }

  private patchIndexFile(path: string) {
    return this.withPersistence(() => {
      if (this.files.has(path)) return;
      const stream = this.getOrCreateIndexStream();
      this.files.add(path);
      stream.write(`/// <reference path="${path}" />\n`);
    });
  }
}
